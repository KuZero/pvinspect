<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pvinspect.data.io API documentation</title>
<meta name="description" content="Read and write images" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pvinspect.data.io</code></h1>
</header>
<section id="section-intro">
<p>Read and write images</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Read and write images&#39;&#39;&#39;

from .image import ModuleImage, ModuleImageSequence, ImageSequence, CellImage
from pathlib import Path
import numpy as np
from typing import Union, Tuple
from skimage import io
from .exceptions import UnsupportedModalityException
from functools import reduce
from tqdm.auto import tqdm
import logging


PathOrStr = Union[Path, str]

def __assurePath(p: PathOrStr) -&gt; Path:
    if isinstance(p, str):
        return Path(p)
    else:
        return p

def read_module_image(path: PathOrStr, modality: int, cols: int = None, rows: int = None) -&gt; ModuleImage:
    &#39;&#39;&#39;Read a single image of a solar module and return it

    Args:
        path (PathOrStr): Path to the file to be read
        modality (int): The imaging modality
        cols (int): Number of columns of cells
        rows (int): Number of rows of cells

    Returns:
        image: The module image
    &#39;&#39;&#39;

    path = __assurePath(path)
    img = io.imread(path, as_gray=True)
    if img.dtype == &#39;&gt;u2&#39;:
        # big endian -&gt; little endian
        img = img.astype(np.uint16)

    return ModuleImage(img, modality, path, cols, rows)

def read_module_images(path: PathOrStr, modality: int, same_camera: bool, cols: int = None, rows: int = None, N: int = 0, pattern: Union[str, Tuple[str]] = (&#39;*.png&#39;, &#39;*.tif&#39;, &#39;*.tiff&#39;, &#39;*.bmp&#39;)) -&gt; ModuleImageSequence:
    &#39;&#39;&#39;Read a sequence of module images and return it

    Args:
        path (PathOrStr): Path to the sequence
        modality (int): The imaging modality
        same_camera (bool): Indicate, if all images are from the same camera and hence share the same intrinsic parameters
        cols (int): Number of columns of cells
        rows (int): Number of rows of cells
        N (int): Only read first N images
        pattern (Union[str, Tuple[str]]): Files must match any of the given pattern

    Returns:
        image: The module image sequence
    &#39;&#39;&#39;

    path = __assurePath(path)

    if isinstance(pattern, str):
        pattern = [pattern]

    # find files and skip if more than N
    imgpaths = list(reduce(lambda x, y: x+y, [list(path.glob(pat)) for pat in pattern]))
    imgpaths.sort()
    if N &gt; 0 and N &lt; len(imgpaths):
        imgpaths = imgpaths[:N]

    imgs = list()
    for fn in tqdm(imgpaths):
        imgs.append(read_module_image(fn, modality, cols, rows))

    if not same_camera:
        homogeneous_types = np.all(np.array([img.dtype == imgs[0].dtype for img in imgs]))
        shapes = [img.shape for img in imgs]
        homogeneous_shapes = np.all(np.array([s == shapes[0] for s in shapes]))
        target_shape = np.max(shapes, axis=0)

        if not homogeneous_shapes:
            logging.warning(&#39;The original images are of different shape. They might not be suited for all applications (for example superresolution).&#39;)

        result = list()
        if not homogeneous_types or not homogeneous_shapes:
            for img in imgs:
                data = img.data
                if not homogeneous_types:
                    data = data.astype(np.float64)      # default type
                if not homogeneous_shapes:
                    tgt = np.full(target_shape, data.min(), dtype=data.dtype)
                    tgt[:data.shape[0],:data.shape[1]] = data
                    data = tgt
                result.append(ModuleImage(data, img.modality, img.path, img.cols, img.rows))
            imgs = result

    return ModuleImageSequence(imgs, copy=False, same_camera=same_camera)

def save_images(path: PathOrStr, sequence: ImageSequence, mkdir: bool = True):
    &#39;&#39;&#39;Write a sequence of images to disk

    Args:
        path (PathOrStr): Target directory
        sequence (ImageSequence): The sequence of images
        mkdir (bool): Automatically create missing directories
    &#39;&#39;&#39;

    path = __assurePath(path)

    if mkdir:
        path.mkdir(parents=True, exist_ok=True)

    for img in tqdm(sequence.images):
        if isinstance(img, CellImage):
            name = &#39;{}_row{:02d}_col{:02d}{}&#39;.format(img.path.stem, img.row, img.col, img.path.suffix)
        else:
            name = img.path.name
        io.imsave(path / name, img.data, check_contrast=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pvinspect.data.io.read_module_image"><code class="name flex">
<span>def <span class="ident">read_module_image</span></span>(<span>path, modality, cols=None, rows=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Read a single image of a solar module and return it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>PathOrStr</code></dt>
<dd>Path to the file to be read</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code>int</code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of columns of cells</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows of cells</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The module image</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_module_image(path: PathOrStr, modality: int, cols: int = None, rows: int = None) -&gt; ModuleImage:
    &#39;&#39;&#39;Read a single image of a solar module and return it

    Args:
        path (PathOrStr): Path to the file to be read
        modality (int): The imaging modality
        cols (int): Number of columns of cells
        rows (int): Number of rows of cells

    Returns:
        image: The module image
    &#39;&#39;&#39;

    path = __assurePath(path)
    img = io.imread(path, as_gray=True)
    if img.dtype == &#39;&gt;u2&#39;:
        # big endian -&gt; little endian
        img = img.astype(np.uint16)

    return ModuleImage(img, modality, path, cols, rows)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.io.read_module_images"><code class="name flex">
<span>def <span class="ident">read_module_images</span></span>(<span>path, modality, same_camera, cols=None, rows=None, N=0, pattern=('*.png', '*.tif', '*.tiff', '*.bmp'))</span>
</code></dt>
<dd>
<section class="desc"><p>Read a sequence of module images and return it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>PathOrStr</code></dt>
<dd>Path to the sequence</dd>
<dt><strong><code>modality</code></strong> :&ensp;<code>int</code></dt>
<dd>The imaging modality</dd>
<dt><strong><code>same_camera</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicate, if all images are from the same camera and hence share the same intrinsic parameters</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of columns of cells</dd>
<dt><strong><code>rows</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of rows of cells</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Only read first N images</dd>
<dt><strong><code>pattern</code></strong> :&ensp;<code>Union</code>[<code>str</code>, <code>Tuple</code>[<code>str</code>]]</dt>
<dd>Files must match any of the given pattern</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The module image sequence</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_module_images(path: PathOrStr, modality: int, same_camera: bool, cols: int = None, rows: int = None, N: int = 0, pattern: Union[str, Tuple[str]] = (&#39;*.png&#39;, &#39;*.tif&#39;, &#39;*.tiff&#39;, &#39;*.bmp&#39;)) -&gt; ModuleImageSequence:
    &#39;&#39;&#39;Read a sequence of module images and return it

    Args:
        path (PathOrStr): Path to the sequence
        modality (int): The imaging modality
        same_camera (bool): Indicate, if all images are from the same camera and hence share the same intrinsic parameters
        cols (int): Number of columns of cells
        rows (int): Number of rows of cells
        N (int): Only read first N images
        pattern (Union[str, Tuple[str]]): Files must match any of the given pattern

    Returns:
        image: The module image sequence
    &#39;&#39;&#39;

    path = __assurePath(path)

    if isinstance(pattern, str):
        pattern = [pattern]

    # find files and skip if more than N
    imgpaths = list(reduce(lambda x, y: x+y, [list(path.glob(pat)) for pat in pattern]))
    imgpaths.sort()
    if N &gt; 0 and N &lt; len(imgpaths):
        imgpaths = imgpaths[:N]

    imgs = list()
    for fn in tqdm(imgpaths):
        imgs.append(read_module_image(fn, modality, cols, rows))

    if not same_camera:
        homogeneous_types = np.all(np.array([img.dtype == imgs[0].dtype for img in imgs]))
        shapes = [img.shape for img in imgs]
        homogeneous_shapes = np.all(np.array([s == shapes[0] for s in shapes]))
        target_shape = np.max(shapes, axis=0)

        if not homogeneous_shapes:
            logging.warning(&#39;The original images are of different shape. They might not be suited for all applications (for example superresolution).&#39;)

        result = list()
        if not homogeneous_types or not homogeneous_shapes:
            for img in imgs:
                data = img.data
                if not homogeneous_types:
                    data = data.astype(np.float64)      # default type
                if not homogeneous_shapes:
                    tgt = np.full(target_shape, data.min(), dtype=data.dtype)
                    tgt[:data.shape[0],:data.shape[1]] = data
                    data = tgt
                result.append(ModuleImage(data, img.modality, img.path, img.cols, img.rows))
            imgs = result

    return ModuleImageSequence(imgs, copy=False, same_camera=same_camera)</code></pre>
</details>
</dd>
<dt id="pvinspect.data.io.save_images"><code class="name flex">
<span>def <span class="ident">save_images</span></span>(<span>path, sequence, mkdir=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Write a sequence of images to disk</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>PathOrStr</code></dt>
<dd>Target directory</dd>
<dt><strong><code>sequence</code></strong> :&ensp;<code>ImageSequence</code></dt>
<dd>The sequence of images</dd>
<dt><strong><code>mkdir</code></strong> :&ensp;<code>bool</code></dt>
<dd>Automatically create missing directories</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_images(path: PathOrStr, sequence: ImageSequence, mkdir: bool = True):
    &#39;&#39;&#39;Write a sequence of images to disk

    Args:
        path (PathOrStr): Target directory
        sequence (ImageSequence): The sequence of images
        mkdir (bool): Automatically create missing directories
    &#39;&#39;&#39;

    path = __assurePath(path)

    if mkdir:
        path.mkdir(parents=True, exist_ok=True)

    for img in tqdm(sequence.images):
        if isinstance(img, CellImage):
            name = &#39;{}_row{:02d}_col{:02d}{}&#39;.format(img.path.stem, img.row, img.col, img.path.suffix)
        else:
            name = img.path.name
        io.imsave(path / name, img.data, check_contrast=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pvinspect.data" href="index.html">pvinspect.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pvinspect.data.io.read_module_image" href="#pvinspect.data.io.read_module_image">read_module_image</a></code></li>
<li><code><a title="pvinspect.data.io.read_module_images" href="#pvinspect.data.io.read_module_images">read_module_images</a></code></li>
<li><code><a title="pvinspect.data.io.save_images" href="#pvinspect.data.io.save_images">save_images</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>